import React from "react";

const words = [
    { word: "algorithm", hint: "A step-by-step procedure to solve a problem" },
    { word: "binary", hint: "A number system with only two digits, 0 and 1" },
    { word: "debug", hint: "Finding and fixing errors in code" },
    { word: "array", hint: "A collection of elements, typically of the same type" },
    { word: "stack", hint: "A linear data structure following LIFO (Last In First Out)" },
    { word: "queue", hint: "A linear data structure following FIFO (First In First Out)" },
    { word: "recursion", hint: "A function that calls itself" },
    { word: "merge", hint: "Combining two sorted arrays into one" },
    { word: "quickSort", hint: "A divide and conquer sorting algorithm" },
    { word: "heap", hint: "A complete binary tree used in priority queues" },
    { word: "bubbleSort", hint: "A simple sorting algorithm with repeated comparisons" },
    { word: "graph", hint: "A collection of nodes (vertices) connected by edges" },
    { word: "depthFirstSearch", hint: "Algorithm for traversing a graph by going deep first" },
    { word: "breadthFirstSearch", hint: "Algorithm for traversing a graph level by level" },
    { word: "dynamicProgramming", hint: "Breaking down problems into simpler subproblems" },
    { word: "greedy", hint: "Algorithm that makes the best local choice at each step" },
    { word: "binarySearch", hint: "Efficient searching technique on sorted arrays" },
    { word: "divideAndConquer", hint: "Breaking down a problem into smaller parts and solving" },
    { word: "hashTable", hint: "A data structure that maps keys to values" },
    { word: "dijkstra", hint: "Algorithm to find the shortest path in a graph" },
    { word: "fibonacci", hint: "A sequence where each number is the sum of the two preceding ones" },
    { word: "bubbleSort", hint: "A simple sorting algorithm that repeatedly steps through the list" },
    { word: "mergeSort", hint: "A divide and conquer algorithm for sorting" },
    { word: "insertionSort", hint: "Sorting algorithm where elements are picked and placed at their correct position" },
    { word: "selectionSort", hint: "Algorithm that selects the smallest element and places it in the correct position" },
    { word: "twoPointer", hint: "Technique used for solving problems with two pointers" },
    { word: "backtracking", hint: "Algorithm that tries all possibilities and backtracks when stuck" },
    { word: "bruteForce", hint: "A straightforward approach to solve problems by testing all possible solutions" },
    { word: "memoization", hint: "Optimization technique that stores results of expensive function calls" },
    { word: "slidingWindow", hint: "Technique for solving problems by maintaining a window" },
    { word: "bitwise", hint: "Operations that directly manipulate bits of data" },
    { word: "topologicalSort", hint: "Sorting vertices of a directed graph" },
    { word: "knapsack", hint: "Optimization problem where the goal is to pack items with the best value" },
    { word: "greedyAlgorithm", hint: "Algorithm that makes locally optimal choices at each step" },
    { word: "simulatedAnnealing", hint: "Probabilistic algorithm to approximate the global optimum" },
    { word: "geneticAlgorithm", hint: "Algorithm based on principles of natural selection" },
    { word: "hashMap", hint: "A data structure that maps keys to values" },
    { word: "heapSort", hint: "Sorting algorithm based on a binary heap" },
    { word: "radixSort", hint: "Sorting algorithm that sorts data digit by digit" },
    { word: "bitMasking", hint: "Technique for manipulating bits in integers" },
    { word: "LCS", hint: "Longest Common Subsequence problem" },
    { word: "LIS", hint: "Longest Increasing Subsequence" },
    { word: "cycleDetection", hint: "Detecting cycles in a graph" },
    { word: "topDown", hint: "Problem-solving technique that starts from the top and solves subproblems" },
    { word: "bottomUp", hint: "Problem-solving technique that starts from the bottom" },
    { word: "exponentiationBySquaring", hint: "Efficient way to compute powers" },
    { word: "networkFlow", hint: "Algorithm for finding the maximum flow in a network" },
    { word: "EulerianPath", hint: "A path in a graph that visits every edge exactly once" },
    { word: "HamiltonianPath", hint: "A path that visits every vertex exactly once" },
    { word: "Kruskal", hint: "A minimum spanning tree algorithm using edge sorting" },
    { word: "Prim", hint: "A minimum spanning tree algorithm using a greedy approach" },
    { word: "BFS", hint: "Breadth-First Search algorithm" },
    { word: "DFS", hint: "Depth-First Search algorithm" },
    { word: "stronglyConnectedComponents", hint: "Algorithm to find strongly connected components in a graph" },
    { word: "segmentTree", hint: "A tree structure used for range queries" },
    { word: "fenwickTree", hint: "Binary indexed tree used for efficient range sum queries" },
    { word: "bitVector", hint: "Efficiently representing sets or data using bits" },
    { word: "radixTree", hint: "A tree that stores strings in a compressed form" },
    { word: "trie", hint: "A tree-like data structure for storing strings" },
    { word: "AVLTree", hint: "A self-balancing binary search tree" },
    { word: "splayTree", hint: "A self-adjusting binary search tree" },
    { word: "redBlackTree", hint: "A balanced binary search tree with red/black nodes" },
    { word: "binaryTree", hint: "A tree where each node has at most two children" },
    { word: "twoDimensionalArray", hint: "An array of arrays" },
    { word: "linkedList", hint: "A data structure where elements are connected using pointers" },
    { word: "doublyLinkedList", hint: "A linked list where nodes are connected in both directions" },
    { word: "circularLinkedList", hint: "A linked list where the last node is connected to the first" },
    { word: "Trie", hint: "A tree-like data structure used for searching words efficiently" },
    { word: "bitTree", hint: "Binary tree representation for bit operations" },
    { word: "heapQueue", hint: "A priority queue implemented using a heap" },
    { word: "shellSort", hint: "Sorting algorithm that generalizes insertion sort" },
    { word: "factorial", hint: "Product of all positive integers up to a given number" },
    { word: "pigeonhole", hint: "Mathematical principle used in proof and algorithm design" },
    { word: "arithmeticProgression", hint: "A sequence of numbers with a constant difference between them" },
    { word: "geometricProgression", hint: "A sequence where each term is multiplied by a constant to get the next term" },
    { word: "combinatorics", hint: "Branch of mathematics dealing with counting and arranging" },
    { word: "derivative", hint: "Rate of change of a function" },
    { word: "integral", hint: "Mathematical concept used to calculate area under a curve" },
    { word: "modulo", hint: "Operation that finds the remainder of division" },
    { word: "bitwiseAnd", hint: "Bitwise operation that returns the common bits" },
    { word: "bitwiseOr", hint: "Bitwise operation that returns 1 if any bit is 1" },
    { word: "xor", hint: "Bitwise operation that returns 1 if exactly one bit is 1" },
    { word: "bigO", hint: "Notation for describing the time complexity of an algorithm" }
  ];
  


export default function chooseRandom() {

  // Correct random selection
  const randomIndex = Math.floor(Math.random() * words.length);
  const randomWord = words[randomIndex];

  return randomWord;
}
