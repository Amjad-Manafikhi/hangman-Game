import React from "react";

const words = [
    { word: "algorithm", hint: "a step-by-step procedure to solve a problem" },
    { word: "binary", hint: "a number system with only two digits, 0 and 1" },
    { word: "debug", hint: "finding and fixing errors in code" },
    { word: "array", hint: "a collection of elements, typically of the same type" },
    { word: "stack", hint: "a linear data structure following lifo (last in first out)" },
    { word: "queue", hint: "a linear data structure following fifo (first in first out)" },
    { word: "recursion", hint: "a function that calls itself" },
    { word: "merge", hint: "combining two sorted arrays into one" },
    { word: "quicksort", hint: "a divide and conquer sorting algorithm" },
    { word: "heap", hint: "a complete binary tree used in priority queues" },
    { word: "bubblesort", hint: "a simple sorting algorithm with repeated comparisons" },
    { word: "graph", hint: "a collection of nodes (vertices) connected by edges" },
    { word: "depthfirstsearch", hint: "algorithm for traversing a graph by going deep first" },
    { word: "breadthfirstsearch", hint: "algorithm for traversing a graph level by level" },
    { word: "dynamicprogramming", hint: "breaking down problems into simpler subproblems" },
    { word: "greedy", hint: "algorithm that makes the best local choice at each step" },
    { word: "binarysearch", hint: "efficient searching technique on sorted arrays" },
    { word: "divideandconquer", hint: "breaking down a problem into smaller parts and solving" },
    { word: "hashtable", hint: "a data structure that maps keys to values" },
    { word: "dijkstra", hint: "algorithm to find the shortest path in a graph" },
    { word: "fibonacci", hint: "a sequence where each number is the sum of the two preceding ones" },
    { word: "bubblesort", hint: "a simple sorting algorithm that repeatedly steps through the list" },
    { word: "mergesort", hint: "a divide and conquer algorithm for sorting" },
    { word: "insertionsort", hint: "sorting algorithm where elements are picked and placed at their correct position" },
    { word: "selectionsort", hint: "algorithm that selects the smallest element and places it in the correct position" },
    { word: "twopointer", hint: "technique used for solving problems with two pointers" },
    { word: "backtracking", hint: "algorithm that tries all possibilities and backtracks when stuck" },
    { word: "bruteforce", hint: "a straightforward approach to solve problems by testing all possible solutions" },
    { word: "memoization", hint: "optimization technique that stores results of expensive function calls" },
    { word: "slidingwindow", hint: "technique for solving problems by maintaining a window" },
    { word: "bitwise", hint: "operations that directly manipulate bits of data" },
    { word: "topologicalsort", hint: "sorting vertices of a directed graph" },
    { word: "knapsack", hint: "optimization problem where the goal is to pack items with the best value" },
    { word: "greedyalgorithm", hint: "algorithm that makes locally optimal choices at each step" },
    { word: "simulatedannealing", hint: "probabilistic algorithm to approximate the global optimum" },
    { word: "geneticalgorithm", hint: "algorithm based on principles of natural selection" },
    { word: "hashmap", hint: "a data structure that maps keys to values" },
    { word: "heapsort", hint: "sorting algorithm based on a binary heap" },
    { word: "radixsort", hint: "sorting algorithm that sorts data digit by digit" },
    { word: "bitmasking", hint: "technique for manipulating bits in integers" },
    { word: "lcs", hint: "longest common subsequence problem" },
    { word: "lis", hint: "longest increasing subsequence" },
    { word: "cycledetection", hint: "detecting cycles in a graph" },
    { word: "topdown", hint: "problem-solving technique that starts from the top and solves subproblems" },
    { word: "bottomup", hint: "problem-solving technique that starts from the bottom" },
    { word: "exponentiationbysquaring", hint: "efficient way to compute powers" },
    { word: "networkflow", hint: "algorithm for finding the maximum flow in a network" },
    { word: "eulerianpath", hint: "a path in a graph that visits every edge exactly once" },
    { word: "hamiltonianpath", hint: "a path that visits every vertex exactly once" },
    { word: "kruskal", hint: "a minimum spanning tree algorithm using edge sorting" },
    { word: "prim", hint: "a minimum spanning tree algorithm using a greedy approach" },
    { word: "bfs", hint: "breadth-first search algorithm" },
    { word: "dfs", hint: "depth-first search algorithm" },
    { word: "stronglyconnectedcomponents", hint: "algorithm to find strongly connected components in a graph" },
    { word: "segmenttree", hint: "a tree structure used for range queries" },
    { word: "fenwicktree", hint: "binary indexed tree used for efficient range sum queries" },
    { word: "bitvector", hint: "efficiently representing sets or data using bits" },
    { word: "radextree", hint: "a tree that stores strings in a compressed form" },
    { word: "trie", hint: "a tree-like data structure for storing strings" },
    { word: "avltree", hint: "a self-balancing binary search tree" },
    { word: "splaytree", hint: "a self-adjusting binary search tree" },
    { word: "redblacktree", hint: "a balanced binary search tree with red/black nodes" },
    { word: "binarytree", hint: "a tree where each node has at most two children" },
    { word: "twodimensionalarray", hint: "an array of arrays" },
    { word: "linkedlist", hint: "a data structure where elements are connected using pointers" },
    { word: "doublylinkedlist", hint: "a linked list where nodes are connected in both directions" },
    { word: "circularlinkedlist", hint: "a linked list where the last node is connected to the first" },
    { word: "trie", hint: "a tree-like data structure used for searching words efficiently" },
    { word: "bitree", hint: "binary tree representation for bit operations" },
    { word: "heapqueue", hint: "a priority queue implemented using a heap" },
    { word: "shellsort", hint: "sorting algorithm that generalizes insertion sort" },
    { word: "factorial", hint: "product of all positive integers up to a given number" },
    { word: "pigeonhole", hint: "mathematical principle used in proof and algorithm design" },
    { word: "arithmeticprogression", hint: "a sequence of numbers with a constant difference between them" },
    { word: "geometricprogression", hint: "a sequence where each term is multiplied by a constant to get the next term" },
    { word: "combinatorics", hint: "branch of mathematics dealing with counting and arranging" },
    { word: "derivative", hint: "rate of change of a function" },
    { word: "integral", hint: "mathematical concept used to calculate area under a curve" },
    { word: "modulo", hint: "operation that finds the remainder of division" },
    { word: "bitwiseand", hint: "bitwise operation that returns the common bits" },
    { word: "bitwiseor", hint: "bitwise operation that returns 1 if any bit is 1" },
    { word: "xor", hint: "bitwise operation that returns 1 if exactly one bit is 1" },
    { word: "bigo", hint: "notation for describing the time complexity of an algorithm" }
  ];
  
  


export default function chooseRandom() {

  // Correct random selection
  const randomIndex = Math.floor(Math.random() * words.length);
  const randomWord = words[randomIndex];

  return randomWord;
}
